https://codeforces.com/contest/2149/problem/E
//第二天数据加强被hack了，可惜 
#include <bits/stdc++.h>
using namespace std;
#define itn int
#define icn cin
#define int long long
#define endl '\n'
typedef pair<int,int> PII;
const int N=2e5+10;
const int INF=1e18;
const int mod=998244353;
#define ll __int128

int Most(const vector<int>& a, int k, int l, int r) {
    int n = a.size();
    unordered_map<int, int> freq;
    int d= 0;
    int count = 0;
    int left = 0;
    for (int right = 0; right < n; right++) {//类滑动窗口 
        if (freq[a[right]] == 0) d++;
        freq[a[right]]++;
        while (d> k) {
            freq[a[left]]--;
            if (freq[a[left]] == 0) d--;
            left++;
        }
        // 现在 [left, right] 内不同元素个数 <= k
        // 需要长度在 [l, r] 之间
        // 长度 = right - left + 1
        // 长度至少 l => left <= right - l + 1
        // 长度至多 r => left >= right - r + 1
        int minL= max(left, right - r + 1);
        int maxL= right - l + 1;

        if (minL<= maxL) {
            count += (maxL - minL+ 1);//有多少合法区间 
        }
    }
    return count;
}
void solve()
{
    int n, k, l, r;
    cin >> n >> k >> l >> r;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    int ans=Most(a, k, l, r) - Most(a, k - 1, l, r);
    cout<<ans<<endl;
   
}
signed main() {
   cin.tie(0)->sync_with_stdio(0);	 
   int T=1; 
   cin>>T;
   while(T--)solve();
    return 0;
}

优化后

#include <bits/stdc++.h>
using namespace std;
#define int long long

int Most(const vector<int>& a, int k, int l, int r) {
    int n = a.size();
    vector<int> freq(n + 1, 0); // 使用vector代替unordered_map vector访问速度快
    int distinct = 0;
    int count = 0;
    int left = 0;
    
    for (int right = 0; right < n; right++) {
        // 扩展右边界
        if (freq[a[right]] == 0) distinct++;
        freq[a[right]]++;
        
        // 收缩左边界直到不同元素数 <= k
        while (distinct > k) {
            freq[a[left]]--;
            if (freq[a[left]] == 0) distinct--;
            left++;
        }
        
        // 现在 [left, right] 内不同元素个数 <= k
        // 我们需要长度在 [l, r] 之间的子数组
        
        // 计算有效的左边界范围
        int min_left = max(left, right - r + 1);
        int max_left = right - l + 1;
        
        if (min_left <= max_left && max_left >= 0) {
            count += max(0LL, max_left - min_left + 1);
        }
    }
    return count;
}

void solve() {
    int n, k, l, r;
    cin >> n >> k >> l >> r;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    
    // 坐标压缩（如果数值范围很大）
    vector<int> b(a);
    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());
    for (int i = 0; i < n; i++) {
        a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1;
    }
    
    int ans = Most(a, k, l, r) - Most(a, k - 1, l, r);
    cout << ans << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int T = 1;
    cin >> T;
    while (T--) solve();
    
    return 0;
}
