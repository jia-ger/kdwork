https://codeforces.com/problemset/problem/1884/C

#include<bits/stdc++.h>
using namespace std;

const int N=1e5+5;
int T,n,m,mx;
struct seg{
	int l,r;
}s[N];
set<int> st;
map<int,int> mp;
int cf[N*2];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>T;
	while(T--){
		mx=0;
		st.clear();
		cin>>n>>m;
		for(int i=1;i<=n;i++){
			cin>>s[i].l>>s[i].r;
			st.insert(s[i].l),st.insert(s[i].r);
		}
		st.insert(1),st.insert(m);
		set<int>::iterator it;
		int xx=0;
		for(it=st.begin();it!=st.end();it++){
			mp[*it]=++xx;
		}
		m=xx;
		for(int i=1;i<=n;i++){
			s[i].l=mp[s[i].l],s[i].r=mp[s[i].r];
		}
      //上面为离散化 因为m很大 不可能1~m全枚举，离散化后再枚举才能保证不超时
      //下面为差分 分两种情况 以1为最小值点，以m为最小值点
		fill(cf+1,cf+m+1,0);
		for(int i=1;i<=n;i++){
			if(s[i].l==1) continue;
			cf[s[i].l]++;
			cf[s[i].r+1]--;
		}
     
		for(int i=1;i<=m;i++){
			cf[i]+=cf[i-1];
			mx=max(mx,cf[i]);
		}
		fill(cf+1,cf+m+1,0);
		for(int i=1;i<=n;i++){
			if(s[i].r==m) continue;
			cf[s[i].l]++;
			cf[s[i].r+1]--;
		}
		for(int i=1;i<=m;i++){
			cf[i]+=cf[i-1];
			mx=max(mx,cf[i]);
		}
		cout<<mx<<'\n';
	}
	return 0;
}

