https://codeforces.com/problemset/problem/1886/D

分析：题中说是加数，我们就可以把所有的操作反过来，从 n 个数字中不断删除数字
首先如果是 >，那么就只能删除最大值，有一种选法。
其次如果是 <，那么只能删除最小值，也只有一种选法。
当操作为 ? 时，那么既不删除最大值，也不删除最小值，有 len−2 种选法，len 是数组长度。
将>/< 变成 ？需要把答案*(i-2) ?变>/< 除以(i-2) 
还要特判，如果在只有两个数字的时候有 ?，那不可能完成！因为除了最大值就是最小值，所以要直接输出 0

#include <bits/stdc++.h>
using namespace std;
const int N = 300010, mod = 998244353;

int n, m, ans;
int modfs[N];
char s[N];

int pow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1ll * res * a % mod;
        a = 1ll * a * a % mod;
        b >>= 1;
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m >> (s + 2);
    for (int i = 1; i <= n; i++) modfs[i] = pow(i, mod - 2);
    ans = 1;
    for (int i = 3; i <= n; i++)
        if (s[i] == '?')
            ans = 1ll * ans * (i - 2) % mod;

    if (s[2] == '?') cout << "0\n";
    else cout << ans << '\n';

    int p;
    char x;
    while (m--) {
        cin >> p >> x;
        p++;
        if (s[p] == '?' && p > 2) ans = 1ll * ans * modfs[p - 2] % mod;
        if (x == '?' && p > 2) ans = 1ll * ans * (p - 2) % mod;
        s[p] = x;
        if (s[2] == '?') cout << "0\n";
        else cout << ans << '\n'; 
    } 
    return 0;
}
