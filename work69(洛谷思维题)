# [NOIP1998 提高组] 车站
## 题目描述
火车从始发站（称为第 $1$ 站）开出，在始发站上车的人数为 $a$，然后到达第 $2$ 站，在第 $2$ 站有人上、下车，但上、下车的人数相同，
因此在第 $2$ 站开出时（即在到达第 $3$ 站之前）车上的人数保持为 $a$ 人。从第 $3$ 站起（包括第 $3$ 站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，
一直到终点站的前一站（第 $n-1$ 站），都满足此规律。现给出的条件是：共有 $n$ 个车站，始发站上车的人数为 $a$，最后一站下车的人数是 $m$（全部下车）。试问 $x$ 站开出时车上的人数是多少？
## 输入格式
输入只有一行四个整数，分别表示始发站上车人数 $a$，车站数 $n$，终点站下车人数 $m$ 和所求的站点编号 $x$。
## 输出格式
出一行一个整数表示答案：从 $x$ 站开出时车上的人数。

NOIP1998 提高组 第一题

首先我们可以把上下车的人数列一个表格，把第二站上车的人数设为b：
车站	第一站	第二站	第三站	第四站	第五站	第六站	第七站	第八站
上车	a	b	a+b	a+2b	2a+3b	3a+5b	5a+8b	……
下车	0	b	b	a+b	a+2b	2a+3b	3a+5b	……
      1，1，2，3，5，8……								
发现了什么？
不就是斐波那契数列吗？
那么我们就可以求出一个站上上车的人数（分别有几个a和b）
由于第一站和第二站a没有连续增加，从第三站才开始连续加，所以一个站上上车的a的系数就是f[第几站-2]。
由于b从第二站就开始连续加了，所以一个站上上车的b的系数就是f[第几站-1];
所以一个站上上车的人数就是f[第几站-2]*a+f[第几站-1]*b;
通过观察表格可知，每一站上还有的人，除这一站上车的人，第一站上车的a人和第二站下车的b人，其余都可以消掉。（自己去看看就知道了）所以在每个站上还有的人数就是：(f[第几站-2]+1)*a+([第几站-1]-1)*b
m实质上就是上一站还有的人，最关键的方程就列出来了：
m=f[n-1-2]*a+f[n-1-1]*b+a-b
化简得：
b=(m-(f[n-3]+1)*a)/(f[n-2]-1)
再把算出来的b带到第x站就行啦！代码很简洁：
#include<bits/stdc++.h>
using namespace std;
int a,n,m,x,b,f[20];
int main(){
    scanf("%d%d%d%d",&a,&n,&m,&x);
    f[1]=1;
    for(int _=2;_<=n-1;f[_]=f[_-1]+f[_-2],_++);
    b=(m-(f[n-3]+1)*a)/(f[n-2]-1);
    cout<<(f[x-2]+1)*a+(f[x-1]-1)*b<<endl;
    return 0;
}
