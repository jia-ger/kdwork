https://www.acwing.com/problem/content/submission/243/

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N=2e6+10;

//只有查询和修改操作可以用树状数组 时间复杂度为log(n) 
int n;
//t[i]表示树状数组i结点覆盖的范围和 
int a[N], t[N];
//Lower[i]表示左边比第i个位置小的数的个数
//Greater[i]表示左边比第i个位置大的数的个数
int Lower[N], Greater[N];

//返回非负整数x在二进制表示下最低位1及其后面的0构成的数值
int lowbit(int x)
{
	return x & -x;
}
//将序列中第x个数加上c
void add(int x,int c)
{
 	for(int i=x;i<=n;i+=lowbit(i))t[i]+=c;
} 
//查询序列前x个数的和
int sum(int x)
{
	int Sum=0;
 	for(int i=x;i;i-=lowbit(i))Sum+=t[i];
 	return Sum;
} 
void sol()
{
  cin>>n;
  for(int i=1;i<=n;i++)cin>>a[i];
  //从左向右，依次统计每个位置左边比第i个数y小的数的个数、以及大的数的个数
  for(int i=1;i<=n;i++)
  {
    int y=a[i];
    //在前面已加入树状数组的所有数中统计在区间[1, y - 1]的数字的出现次数
	Lower[i]=sum(y-1);
	//在前面已加入树状数组的所有数中统计在区间[y + 1, n]的数字的出现次数
	Greater[i]=sum(n)-sum(y);
	//将y加入树状数组，即数字y出现1次
	add(y,1);	
  } 

  memset(t,0,sizeof t);
  int ansV=0,ansA=0;
  //从右往左计算  
  for(int i=n;i>=1;i--)
  {
  	int y=a[i];
  	ansV+=Greater[i]*(sum(n)-sum(y));
  	ansA+=Lower[i]*sum(y-1);
  	add(y,1);
  }
  cout<<ansV<<" "<<ansA<<endl; 
}

signed main() {
	cin.tie(0)->sync_with_stdio(0);
	int t=1;
//	cin>>t;
	while(t--)sol();
}
