https://codeforces.com/contest/2139/problem/D

#include <bits/stdc++.h>
using namespace std;
#define itn int
#define icn cin
#define int long long
#define endl '\n'
typedef pair<int,int> PII;
const int N=1e5+10;
const int INF=1e18;
const int mod=998244353;
#define ll __int128


void solve()
{   
   //方法2只有存在 ai>aj>ak 且 i<j<k; 才会有利 
   int n,q;cin>>n>>q;
   vector<int>a(n+2);
   for(int i=1;i<=n;i++)cin>>a[i];
     vector<int> mxl(n + 1), mir(n + 1);
    for (int i = 1; i <= n; i++)
    {
        mxl[i] = i - 1;
        while (mxl[i] > 0 && a[mxl[i]] < a[i])
            mxl[i] = mxl[mxl[i]];
    }
    for (int i = n; i >= 1; i--)
    {
        mir[i] = i + 1;
        while (mir[i] <= n && a[mir[i]] > a[i])
            mir[i] = mir[mir[i]];
    }
    vector<int> L(n + 1, 0);//存的是每个区间 （mxl,i,mir） 
    for (int i = 2; i < n; i++)
    {
        if (mxl[i] > 0 && mir[i] <= n)
        {
            L[mir[i]] = max(L[mir[i]], mxl[i]);//每个右区间所对应的左区间 
        }
    }
    for (int i = 1; i <= n; i++)
    {
        L[i] = max(L[i], L[i - 1]);//后面区间可能会包含前置区间 
    }
    for (int i = 0; i < q; i++)
    {
        int l, r;
        cin >> l >> r;
        if (l <= L[r])//给的区间包含一个（mxl,i,mir区间，说明可以通过方法2来减少操作次数 
            cout << "NO\n";
        else
            cout << "YES\n";
    }
} 



signed main(){
   cin.tie(0)->sync_with_stdio(0);	 
   int T=1; 
   cin>>T;
   while(T--)solve();
   
    return 0;
}
