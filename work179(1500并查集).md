https://codeforces.com/problemset/problem/2060/E

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m1,m2,f[2*114514],g[2*114514],ans,cntf,cntg,T;
int u[2*114514],v[2*114514];
int find(int x,int* a){
	if(a[x]==x) return x;
	else return a[x]=find(a[x],a);
}
int main(){
	cin>>T;
	while(T--){
		cntf=cntg=ans=0;
		cin>>n>>m1>>m2;	
		for(int i=1;i<=n;i++) f[i]=i,g[i]=i;//初始化
		for(int i=1;i<=m1;i++) cin>>u[i]>>v[i];//存储F中的边
		for(int i=1;i<=m2;i++){
			int x,y;
			cin>>x>>y;
			int fx=find(x,g),fy=find(y,g);
			if(fx!=fy) g[fx]=fy;//创建G并查集
		}
		for(int i=1;i<=m1;i++){
			if(find(u[i],g)==find(v[i],g)){//如果这两个点在G中处于同一集合，那么就连边
				int fx=find(u[i],f),fy=find(v[i],f);
				f[fx]=fy;
			}
			else ans++;//否则不连边（也就是删边，所以ans++）
		}
		for(int i=1;i<=n;i++){
			if(f[i]==i) cntf++;
			if(g[i]==i) cntg++;//算出两个并查集的集合数
		}
		cout<<ans+(cntf-cntg)<<endl;//cntf-cntg即为需要连的边的数量
	}
} 
```
