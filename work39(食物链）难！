题目描述
动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。
有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。
此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。
1） 当前的话与前面的某些真的话冲突，就是假话；
2） 当前的话中X或Y比N大，就是假话；
3） 当前的话表示X吃X，就是假话。
你的任务是根据给定的N和K句话，输出假话的总数。

输入格式
第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。
输出格式
只有一个整数，表示假话的数目。数据范围1≤N≤500001≤𝑁≤500000≤K≤1000000≤𝐾≤100000样例输入：
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
输出：
3
算法(带权并查集) 时间复杂度O(1)任意的X和Y两个动物，总共有三种关系
1. X和Y是同类
2. X吃Y(X是捕食者)
3. X被Y吃(X是猎物)
问题的核心在于对于任意的X和Y，如何去确定X和Y的关系。
题目说有三类动物，形成了一个环形，A吃B，B吃C，C吃A，这就和数学中的取模很相似，0->1->2->3(3即是0)我们采用数组d[i]
来代表i节点到父节点的代数，通过dmod3转化为0,1,2三代的关系。d[x]mod3==d[y]mod3对应X与Y为同类，具体可以是，同为0代，同为1代，同为2代
(d[x]+1)mod3==d[y]mod3对应X吃Y，(d[x]+2)mod3==d[y]mod3 对应X被Y吃，同上至此我们已经判断出X和Y的关系，也能很容易判断真话假话。
假话：
1. X或Y过界
2. X和Y都已经出现过（在并查集中），并且当前关系与并查集中的关系不同
真话：
1.X和Y未都出现过（需要加入并查集）
2.X和Y已经出现过，并且当前关系与并查集中的关系一致

C++ 代码
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1e5+5;
int p[N],d[N];  
//p[i] 代表i的父节点
//d[i] 代表i到它的父节点距离,在全局变量中默认值为0

int find(int x){
    if(x!=p[x]) {
        int root = find(p[x]);  //此行会把p[x]的父节点更新成祖宗节点
        d[x] = d[x] + d[p[x]];  //d[p[x]]就指p[x]到祖宗节点的距离
        p[x] = root;   
    }
    return p[x];
}

int main(){
    int n,k;
    cin>>n>>k;
    for(int i=0;i<n;i++) p[i] = i;
    int cnt = 0;
    while(k--){
        int no,x,y;
        cin>>no>>x>>y;
        if(x>n || y>n) cnt++;
        else{
            int rx=find(x),ry = find(y);
            if(no==1) {
                if(rx == ry && (d[x]-d[y])%3) cnt++;
                else if(rx!=ry){        //执行合并集合操作
                    p[rx] = ry;
                    d[rx] = d[y] - d[x];    //此处增加的距离是上面if条件的相反数
                }
            }else{
                if(rx == ry && (d[x]-d[y]-1)%3) cnt++;
                else if(rx!=ry){        //执行合并集合操作
                    p[rx] = ry;
                    d[rx] = d[y] + 1 - d[x];     //此处增加的距离是上面if条件的相反数 
                }
            }
        }
    }
    printf("%d\n",cnt);
    return 0;
}

作者：chocolate-emperor
链接：https://www.acwing.com/solution/content/24842/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
