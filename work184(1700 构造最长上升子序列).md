https://codeforces.com/problemset/problem/1894/D

> 分析：特别像acwing 最长上升子序列2的优化 弄明白那个优化就理解这个了

```
#include <bits/stdc++.h>
using namespace std;
#define itn int
#define icn cin
#define int long long
#define endl '\n'
typedef pair<int,int> PII;
const int N=2e5+10;
const int INF=1e18;
const int mod=1e9+7;
#define ll __int128


int a[N],b[N],l,r,p; 
void solve() {
	int n,m;
	cin>>n>>m;

	for(int i=1; i<=n; i++)
		cin>>a[i];
	for(int i=1; i<=m; i++)
		cin>>b[i];
	sort(b+1,b+m+1);
	r=m;
	for(int i=1; i<=n; i++) {
		l=0;
		p=r;
		while(l<r) {
			if(b[(l+r)/2+1]>=a[i]) r=(l+r)/2;
			else l=(l+r)/2+1;
		}
		for(int j=p; j>r; j--)
			cout<<b[j]<<" ";
		cout<<a[i]<<" ";
	}
	for(int i=r; i>0; i--)
		cout<<b[i]<<" ";
	cout<<endl;
}


signed main() {
	cin.tie(0)->sync_with_stdio(0);
	int T=1;
	cin>>T;

	while(T--)solve();

	return 0;
}
```
