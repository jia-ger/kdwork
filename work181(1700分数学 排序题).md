https://codeforces.com/problemset/problem/1889/B

> 分析：这题有一个很精妙的结论：图中无边时，如果 (i,j) 可以连接，那么 (1,i) 与 (1,j) 必能连接其一
我们可以用反证法来证明：
如果对于任何的 2≤k≤n， (1,k) 都不能连接，那么便有：`a_k​<k*c   a_i*a_j<(i+j)*c<i*j*c`，在这种情况下，不存在 (i,j) 可以互相连接
于是我们就可以把除了 1 以外的点进行排序，把“更加可能与 1 连接得上的点”排在前面，然后按照次序判断是否能与 1 连接
如何具体地描述“更加可能与 1 连接得上的点”呢？我们可以记与 1 连通的点的点权和为 sum，由于点 i 与点 1 连接得上的限制是：`sum+a_i≥i⋅c`，所以只有当 `sum≥i×c−a_i`
时才能连接上故我们可以预处理出每个点的 $$i×c−a_i$$值，然后对这个值进行由小到大的排序。这样就把最可能连接的点放在了前面。

```c++
#include <bits/stdc++.h>
using namespace std;
#define itn int
#define icn cin
#define int long long
#define endl '\n'
typedef pair<int,int> PII;
const int N=2e5+10;
const int INF=1e18;
const int mod=998244353;
#define ll __int128

struct abd{
	int pos;//位置 
	int d;//人数 
	int w;//按这个从小到大排序 
}q[N];
void solve()
{
  itn n,c;cin>>n>>c;
 
  for(itn i=1;i<=n;i++)
  {
  	int d;cin>>d;
  	int w=i*c-d;
  	q[i]={i,d,w};
  }
  sort(q+2,q+n+1,[&](abd qq,abd pp){
  	return qq.w<pp.w;
  });
  int sum=q[1].d;
  for(int i=2;i<=n;i++)
  {
   	if(sum>=q[i].w)sum+=q[i].d;
   	else
   	{
   	  cout<<"No"<<endl;return;	
	}
  } 
   cout<<"Yes"<<endl;
} 


signed main() 
{
	cin.tie(0)->sync_with_stdio(0);
	int T=1;
	cin>>T;
	while(T--)solve();

	return 0;
}
```
